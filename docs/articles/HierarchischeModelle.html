<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hierarchische Modelle • bayeskurs</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">bayeskurs</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Hierarchische Modelle</h1>
                        <h4 class="author">Volker Schmid</h4>
            
            <h4 class="date">19./26. Juni 2017</h4>
          </div>

    
    
<div class="contents">
<div id="hierarchische-modelle" class="section level1">
<h1 class="hasAnchor">
<a href="#hierarchische-modelle" class="anchor"></a>Hierarchische Modelle</h1>
<div id="hierarchische-modelle-1" class="section level2">
<h2 class="hasAnchor">
<a href="#hierarchische-modelle-1" class="anchor"></a>Hierarchische Modelle</h2>
<p>Ein sogenanntes hierarchisches Modell umfasst mehrere Schichten, oft drei:</p>
<ul>
<li>Level 1: Datenmodell, Definition der Likelihood</li>
<li>Level 2: Priori-Modell der unbekannten Parameter</li>
<li>Level 3: (Hyper-)Prioris der Prioriparameter in Level 2</li>
</ul>
</div>
<div id="beispiel-zeitreihe-mit-saison-effekt" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#beispiel-zeitreihe-mit-saison-effekt" class="anchor"></a>Beispiel: Zeitreihe mit Saison-Effekt</h2>
<ul>
<li>Anzahl von getöteten oder schwer verletzten Autofahrern in England von Januar 1969 bis Dezember 1984</li>
</ul>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-1-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-2-1.png" width="672"></p>
<ul>
<li>Klarer Saisonaler Effekt</li>
<li>Eventuell Trend über die Jahre</li>
<li>Einfluß des Sicherheitsgurts</li>
</ul>
</div>
<div id="datenmodell" class="section level2">
<h2 class="hasAnchor">
<a href="#datenmodell" class="anchor"></a>Datenmodell</h2>
<ul>
<li>wir nehmen <span class="math inline">\(\sqrt{y}\)</span> als normalverteilt an</li>
</ul>
<p><span class="math display">\[ 
\sqrt{y_i} \sim N(\mu_i, \sigma^2); i=1,\ldots,T=192 
\]</span></p>
<ul>
<li>wir teilen den Erwartungswert <span class="math inline">\(\mu_i\)</span> in verschiedene Effekte auf:</li>
</ul>
<p><span class="math display">\[
\mu_i = \alpha + \beta x_i + \gamma_i + \delta_i
\]</span></p>
<p>mit <span class="math inline">\(i\)</span> Monat, <span class="math inline">\(x_i\)</span> Dummyvariable Gurtpflicht ja/nein.</p>
</div>
<div id="priori-modell---zeittrend" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#priori-modell---zeittrend" class="anchor"></a>Priori-Modell - Zeittrend</h2>
<ul>
<li>Lineares Modell wäre vermutlich falsch</li>
<li>Parametrische Modellierung eventuell möglich, aber welches Modell?</li>
<li>Idee: Dummykodierung, ein Parameter pro Monat</li>
<li>Aber: zu viele Parameter</li>
<li>Idee: Aufeinander folgende Monate haben ähnliche Parameter</li>
<li>Random Walk-Priori (1. Ordnung)</li>
</ul>
<p><span class="math display">\[ 
\gamma_i|\gamma_{i-1},\tau_c \sim N(\gamma_{i-1},\tau_c^{-1}); j=2,\ldots,T; \;p(\gamma_1)\propto const.\]</span></p>
<p>Es gilt: <span class="math display">\[
\gamma|\tau_c \sim N_T\left(0,(\tau_c Q_c)^{-1}\right)
\]</span></p>
<p>mit <span class="math display">\[Q_c = \left(\begin{array}{rrrrrr}
 1 &amp; -1 &amp;  &amp;  &amp;  &amp;  \\
-1 &amp;  2 &amp; -1 &amp;  &amp;  &amp; \\
  &amp; -1 &amp;  2 &amp; -1     &amp;  &amp; \\
  &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \\
  &amp; &amp;  &amp; -1 &amp; 2 &amp; -1\\
 &amp;  &amp;  &amp;  &amp; -1 &amp; 1
\end{array}\right)
\]</span> (fehlende Einträge sind 0)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(Matrix)
Qc &lt;-<span class="st"> </span>Matrix::<span class="kw">sparseMatrix</span>(<span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>:T,<span class="dv">1</span>:(T<span class="dv">-1</span>)),
        <span class="dt">j=</span><span class="kw">c</span>(<span class="dv">1</span>:T,<span class="dv">2</span>:T), 
        <span class="dt">x=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="kw">rep</span>(<span class="dv">2</span>,T<span class="dv">-2</span>),<span class="dv">1</span>,<span class="kw">rep</span>(-<span class="dv">1</span>,T<span class="dv">-1</span>)),
        <span class="dt">symmetric =</span> <span class="ot">TRUE</span>)
<span class="kw">image</span>(Qc)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-3-1.png" width="672"></p>
</div>
<div id="priorimodell---saisontrend" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#priorimodell---saisontrend" class="anchor"></a>Priorimodell - Saisontrend</h2>
<ul>
<li>Möglich wäre z.B. parametrische Sinus-Kurve, aber vermutlich zu unflexibel</li>
<li>Sehr flexibel: Dummykodierung für jeden Monat. Aber: Viele Parameter, zu wenig Information</li>
<li>Idee: Gleicher Monat im Folgenden Jahr hat ähnlichen Parameter. Die Summe über <span class="math inline">\(m=12\)</span> Monate ist daher ähnlich (normal)verteilt. Formuliert als Priori-Information:</li>
</ul>
<p><span class="math display">\[ \begin{aligned}
p(\delta|\tau_d)&amp;\propto (\tau_d^{T-m+1})/2\cdot\\ &amp;\cdot\exp\left(-\frac{\tau_d}{2}\sum_{i=1}^{T-m+1}(\delta_i+\delta_{i+1}+\ldots+\delta_{i+m-1})^2\right)
\end{aligned}
\]</span></p>
<ul>
<li>Es lässt sich zeigen: <span class="math display">\[ \delta|\tau_d \sim N_T\left(0,(\tau_d Q_d)^{-1}\right)\]</span> mit</li>
</ul>
<p><span class="math display">\[Q_d=\left(\begin{array}{cccccccccc}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 &amp;  &amp;  &amp;  &amp; \\
1 &amp; 2 &amp; 2 &amp; \cdots &amp; 2 &amp; 2 &amp; 1 &amp;  &amp;  &amp; \\
1 &amp; 2 &amp; 3 &amp; \cdots &amp; 3 &amp; 3 &amp; 2 &amp; 1 &amp;  &amp; \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots \\
1 &amp; 2 &amp; 3 &amp; \cdots &amp; 11 &amp; 12 &amp; 11 &amp; 10 &amp; \cdots \\
&amp; 1 &amp; 2 &amp; 3 &amp; \cdots &amp; 11 &amp; 12 &amp; 11 &amp; 10 &amp; \cdots \\
&amp; &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \\
\end{array}\right)\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Qd &lt;-<span class="st"> </span>Matrix::<span class="kw">sparseMatrix</span>(<span class="dt">i=</span>T,<span class="dt">j=</span>T,<span class="dt">x=</span><span class="dv">0</span>,
        <span class="dt">symmetric =</span> <span class="ot">TRUE</span>)
EinsM&lt;-Matrix::<span class="kw">sparseMatrix</span>(<span class="dt">i=</span><span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">12</span>,<span class="dv">12</span>),
        <span class="dt">j=</span><span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">12</span>,<span class="dt">each=</span><span class="dv">12</span>), <span class="dt">x=</span><span class="dv">1</span>)
for (i in <span class="dv">1</span>:(T<span class="dv">-12</span>))
  Qd[i+(<span class="dv">0</span>:<span class="dv">11</span>),i+(<span class="dv">0</span>:<span class="dv">11</span>)]&lt;-Qd[i+(<span class="dv">0</span>:<span class="dv">11</span>),i+(<span class="dv">0</span>:<span class="dv">11</span>)]+EinsM
<span class="kw">image</span>(Qd)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-4-1.png" width="672"></p>
</div>
<div id="priori-modell---intercept-und-kovariableneffekt" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#priori-modell---intercept-und-kovariableneffekt" class="anchor"></a>Priori-Modell - Intercept und Kovariableneffekt</h2>
<ul>
<li>Keine Priori-Information</li>
</ul>
<p><span class="math display">\[p(\alpha)\propto const. \Leftrightarrow ''\alpha\sim N\left(0,0^{-1}\right)'' \]</span></p>
<ul>
<li>Analog <span class="math inline">\(p(\beta)\propto const.\)</span>
</li>
<li>Also: Alle Effekte a priori normalverteilt, enthalten unbekannte Präzisionsparameter <span class="math inline">\(\tau_c\)</span> bzw. <span class="math inline">\(\tau_d\)</span>
</li>
<li>Gemeinsame Priori von <span class="math inline">\(\theta=(\alpha,\beta,\gamma,\delta)\)</span> hat Form</li>
</ul>
<p><span class="math display">\[ 
\begin{aligned}
\theta|\tau &amp;\sim N_{2+2T}(0,Q(\tau)^{-1})\\
Q(\tau)&amp;=\left(\begin{array}{cccc}
0&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;0\\
0&amp;0&amp;\tau_cQ_c &amp;0\\
0&amp;0&amp;0&amp;\tau_dQ_d\\
\end{array}\right)
\end{aligned}
\]</span></p>
</div>
<div id="hyperpriors" class="section level2">
<h2 class="hasAnchor">
<a href="#hyperpriors" class="anchor"></a>Hyperpriors</h2>
<ul>
<li>Die Präzisionsparameter in den Prioris steuern, wie stark die Regularisierung des Zeit- bzw. Saisontrends ist</li>
<li>Diese Parameter der Prioris, <em>Hyperparameter</em>, wollen wir nicht vorgeben, sondern mitschätzen</li>
<li>Jeder Parameter, der geschätzt werden soll, braucht eine Priori, hier <em>Hyperpriori</em> genannt</li>
</ul>
<p><span class="math display">\[ \begin{aligned}
\tau_c\sim Ga(a_c,b_c)\\
\tau_d\sim Ga(a_d,b_d)
\end{aligned} \]</span></p>
<ul>
<li>Außerdem brauchen wir noch eine Priori für <span class="math inline">\(\sigma^2\sim IG(a_s,b_s)\)</span>
</li>
</ul>
</div>
<div id="posteriori" class="section level2">
<h2 class="hasAnchor">
<a href="#posteriori" class="anchor"></a>Posteriori</h2>
<p>Sei <span class="math inline">\(y^*=\sqrt{y}\)</span></p>
<p><span class="math display">\[ \begin{aligned}
p(\theta,\tau|y^*) &amp;\propto f(y^*|\theta) p(\theta,\tau)\\
&amp;\propto f(y^*|\theta) p(\theta|\tau) p(\tau) \\
&amp;\propto \prod_{i=1}^T \sigma^{-1} \exp\left(-\frac{1}{2\sigma^2}(y_i^*-\alpha-\beta x_i-\gamma_i+\delta_i )^2\right) \cdot\\
&amp;\cdot \tau_c^{(T-1)/2} \exp\left(-\frac{\tau_c}{2}\gamma^TQ_c\gamma\right)
\tau_d^{(T-m+1)/2} \exp\left(-\frac{\tau_d}{2}\delta^TQ_d\delta\right)\\
&amp;\cdot \tau_c^{a_c-1}\exp(-\tau_c b_c)\cdot \tau_d^{a_d-1}\exp(-\tau_d b_d)\\
&amp;\cdot (\sigma^2)^{-a_s-1}\exp(-b_s/\sigma^2)
\end{aligned} \]</span></p>
</div>
<div id="full-conditional---zeitlicher-trend" class="section level2">
<h2 class="hasAnchor">
<a href="#full-conditional---zeitlicher-trend" class="anchor"></a>Full conditional - Zeitlicher Trend</h2>
<p><span class="math display">\[ \begin{aligned}
p(\gamma|\cdot) &amp;\propto \exp\left(-\frac{1}{2\sigma^2}\sum_i(y_i^*-\gamma_i-\delta_i-\beta x_i-\alpha )^2\right) \cdot \exp\left(-\frac{\tau_c}{2}\gamma^TQ_c\gamma\right)\\
&amp;\propto\exp\left(-\frac{1}{2\sigma^2}\sum_i(\gamma_i-\epsilon^{c}_i)^2-\frac{\tau_c}{2}\gamma^TQ_c\gamma\right)\\
&amp;\propto \exp\left(-\frac{1}{2}\gamma^T\frac{T}{\sigma^2}I\gamma+\frac{1}{\sigma^2}\gamma^T\epsilon_c^*-\frac{1}{2}\gamma^T\tau_cQ_c\gamma\right)\\
&amp;\propto \exp\left(-\frac{1}{2}\gamma^T\left(\frac{T}{\sigma^2}I+\tau_cQ_c\right)\gamma+\frac{1}{\sigma^2}\gamma^T\epsilon_c^*\right)
\end{aligned} \]</span></p>
<p>Kanonische Form der Normalverteilung mit Präzisionsmatrix <span class="math inline">\(Q_c^*=\left(\frac{1}{\sigma^2}I+\tau_cQ_c\right)\)</span> und Erwartungswert <span class="math inline">\(Q_c^{*-1}m_c\)</span> mit <span class="math inline">\(m_{c,i}=\frac{1}{\sigma^2}\sum_{i}(y_i^*-\alpha-\beta x_i-\delta_i)\)</span>.</p>
</div>
<div id="full-conditional---saison-effekt" class="section level2">
<h2 class="hasAnchor">
<a href="#full-conditional---saison-effekt" class="anchor"></a>Full conditional - Saison-Effekt</h2>
<p>Analog: <span class="math display">\[
\begin{aligned}
\delta|\cdot &amp;\sim N_{T}((Q_d^*)^{-1}m_d,(Q_d^*)^{-1})\\
Q_d^* &amp;=\left(\frac{1}{\sigma^2}I+\tau_dQ_d\right)\\
m_{d,k}&amp;=\frac{1}{\sigma^2}\sum_{i}(y_i^*-\alpha-\beta x_i-\gamma_i)
\end{aligned}
\]</span></p>
</div>
<div id="full-conditional---kovariableneffekt" class="section level2">
<h2 class="hasAnchor">
<a href="#full-conditional---kovariableneffekt" class="anchor"></a>Full conditional - Kovariableneffekt</h2>
<p><span class="math display">\[ \begin{aligned}
p(\beta|\cdot) &amp;\propto \exp\left(-\frac{1}{2\sigma^2}\sum_i(y_i^*-\gamma-\delta-\alpha-\beta x_i)^2\right)\\
&amp;\propto \exp\left(-\frac{1}{2}\beta^2\frac{1}{\sigma^2}\sum_i x_i^2 + 
\beta \frac{1}{\sigma^2}\sum_i(x_iy_i^*-x_i\alpha-x_i\gamma_i-x_i\delta_i)\right)
\end{aligned}\]</span></p>
<p>Also <span class="math inline">\(\beta|\cdot \sim N(q_b^{-1}m_b,q_b^{-1})\)</span> mit <span class="math inline">\(q_b=\frac{\sum x_i^2}{\sigma^2}\)</span> und <span class="math inline">\(m_b=\frac{1}{\sigma 2}\sum_i(x_iy_i^*-x_i\alpha-x_i\gamma_j-x_i\delta_k)\)</span></p>
<ul>
<li>Analog: <span class="math inline">\(\alpha|\cdot \sim N(q_a^{-1}m_a,q_a^{-1})\)</span> mit <span class="math inline">\(q_a=\frac{T}{\sigma^2}\)</span> und <span class="math inline">\(m_b=\frac{1}{\sigma 2}\sum_i(y_i^*-x_i\beta-\gamma_j-\delta_k)\)</span>
</li>
</ul>
</div>
<div id="full-conditional---prazisionsparameter" class="section level2">
<h2 class="hasAnchor">
<a href="#full-conditional---prazisionsparameter" class="anchor"></a>Full Conditional - Präzisionsparameter**</h2>
<p>Allgemein: <span class="math inline">\(p(\tau|\cdot) \propto p(\theta|\tau)p(\tau)\)</span>, also ist die Full Conditional unabhängig von den Daten</p>
<p>Konkret:</p>
<p><span class="math display">\[ \begin{aligned}
p(\tau_c|\cdot) &amp;\propto \tau_c^{(T-1)/2} \exp{\left(\frac{\tau_c}{2}\gamma^TQ_c\gamma\right)} \tau_c^{a_c-1}\exp(-\tau_c b_c)\\
&amp;\propto \tau_c^{c+(T-1)/2-1}\exp\left(-\tau_c(b_c+\gamma^T Q_c\gamma/2) \right)
\end{aligned} \]</span></p>
<p>Also</p>
<p><span class="math display">\[ \begin{aligned}
\tau_c|\cdot &amp;\sim Ga\left(a_c+(T-1)/2, b_c+\gamma^T Q_c\gamma/2\right)\\
\tau_d|\cdot &amp;\sim Ga\left(a_d+(T-m+1)/2, b_d+\delta^T Q_d\delta/2\right)\\
\sigma_2|\cdot &amp;\sim IG\left(a_s+T/2, b_s+\sum(y_i^*-\alpha-x_i\beta+\gamma_j-\delta_k)^2\right)
\end{aligned}\]</span></p>
</div>
<div id="implementation" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#implementation" class="anchor"></a>Implementation</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">sqrt</span>(Drivers$y)
belt &lt;-<span class="st"> </span>Drivers$belt

a.c &lt;-<span class="st"> </span>a.d &lt;-<span class="st"> </span><span class="dv">1</span>
b.c &lt;-<span class="st"> </span><span class="fl">0.0005</span>
b.d &lt;-<span class="st"> </span><span class="fl">0.1</span>
a.s &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="dv">4</span>
b.s &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="dv">4</span>

alpha &lt;-<span class="st"> </span><span class="kw">mean</span>(y)
beta &lt;-<span class="st"> </span><span class="dv">0</span>
gamma &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,T)
delta &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,T)
tau.c &lt;-<span class="st"> </span>a.c/b.c
tau.d &lt;-<span class="st"> </span>a.d/b.d
sigma2 &lt;-<span class="st"> </span>b.s/a.s</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sumx2 &lt;-<span class="st"> </span><span class="kw">sum</span>(belt)
burnin=<span class="dv">1000</span>
nr.it=<span class="dv">5000</span>
I =<span class="st"> </span>burnin+nr.it

alpha.save&lt;-beta.save&lt;-sigma2.save&lt;-<span class="kw">rep</span>(<span class="dv">0</span>,nr.it)
gamma.save&lt;-<span class="kw">array</span>(<span class="dv">0</span>,<span class="kw">c</span>(T,nr.it))
delta.save&lt;-<span class="kw">array</span>(<span class="dv">0</span>,<span class="kw">c</span>(T,nr.it))
tau.save&lt;-<span class="kw">array</span>(<span class="dv">0</span>,<span class="kw">c</span>(<span class="dv">2</span>,nr.it))
iter=<span class="dv">0</span></code></pre></div>
</div>
<div id="mcmc" class="section level2">
<h2 class="hasAnchor">
<a href="#mcmc" class="anchor"></a>MCMC</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bayeskurs)</code></pre></div>
<pre><code>## 
## Attache Paket: 'bayeskurs'</code></pre>
<pre><code>## The following object is masked _by_ '.GlobalEnv':
## 
##     y</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">while (iter&lt;I)
{
  iter=iter<span class="dv">+1</span>
  gamma&lt;-gamma-<span class="kw">mean</span>(gamma);  delta&lt;-delta-<span class="kw">mean</span>(delta)
  m &lt;-<span class="st"> </span><span class="kw">sum</span>(y-gamma-delta-belt*gamma)/sigma2; Q &lt;-<span class="st"> </span>T/sigma2
  alpha &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, m/Q, <span class="dv">1</span>/Q)
  m &lt;-<span class="st"> </span><span class="kw">sum</span>(belt*(y-gamma-delta-alpha))/sigma2; Q &lt;-<span class="st"> </span>sumx2/sigma2
  beta &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, m/Q, <span class="dv">1</span>/Q)
  m &lt;-<span class="st"> </span>(y-delta-beta*belt-alpha)/sigma2; Q &lt;-<span class="st"> </span>tau.c*Qc +<span class="st"> </span>Matrix::<span class="kw">Diagonal</span>(T)/sigma2
  gamma &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rmvnormcanon.html">rmvnormcanon</a></span>(m,Q)
  m &lt;-<span class="st"> </span>(y-gamma-beta*belt-alpha)/sigma2; Q &lt;-<span class="st"> </span>tau.d*Qd +<span class="st"> </span>Matrix::<span class="kw">Diagonal</span>(T)/sigma2
  delta &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rmvnormcanon.html">rmvnormcanon</a></span>(m,Q)
  tau.c &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, a.c +<span class="st"> </span>(T<span class="dv">-1</span>)/<span class="dv">2</span>, b.c +<span class="st"> </span>(<span class="kw">t</span>(gamma)%*%Qc%*%gamma/<span class="dv">2</span>)[<span class="dv">1</span>,<span class="dv">1</span>])
  tau.d &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, a.d +<span class="st"> </span>(T<span class="dv">-12+1</span>)/<span class="dv">2</span>, b.d +<span class="st"> </span>(<span class="kw">t</span>(delta)%*%Qd%*%delta/<span class="dv">2</span>)[<span class="dv">1</span>,<span class="dv">1</span>])
  sigma2 &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="kw">rgamma</span>(<span class="dv">1</span>, a.s +<span class="st"> </span>T/<span class="dv">2</span>, b.s +<span class="st"> </span><span class="kw">sum</span>((y-alpha-gamma-delta-beta*belt)^<span class="dv">2</span>))
  
  if (iter&gt;burnin){alpha.save[iter-burnin]&lt;-alpha;  beta.save[iter-burnin]&lt;-beta
    gamma.save[,iter-burnin]&lt;-gamma; delta.save[,iter-burnin]&lt;-delta
    tau.save[,iter-burnin]&lt;-<span class="kw">c</span>(tau.c,tau.d); sigma2.save[iter-burnin]&lt;-sigma2
  }
}</code></pre></div>
</div>
<div id="ergebnisse" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#ergebnisse" class="anchor"></a>Ergebnisse</h2>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-8-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-9-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-11-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-12-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-13-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-15-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-17-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-18-1.png" width="672"></p>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-19-1.png" width="672"></p>
</div>
<div id="bayesx" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#bayesx" class="anchor"></a>BayesX</h2>
<blockquote>
<p>BayesX is a software tool for estimating <strong>structured additive regression</strong> models. Structured additive regression embraces several well-known regression models such as generalized additive models (GAM), generalized additive mixed models (GAMM), generalized geoadditive mixed models (GGAMM), dynamic models, varying coefficient models, and geographically weighted regression within a unifying framework…</p>
</blockquote>
<div class="figure">
<img src="pics/bayesX.png" alt="BayesX Logo"><p class="caption">BayesX Logo</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#install.packages(c("BayesXsrc","BayesX"), type = "source") </span>
<span class="kw">library</span>(R2BayesX)</code></pre></div>
<pre><code>## Lade nötiges Paket: BayesXsrc</code></pre>
<pre><code>## Lade nötiges Paket: colorspace</code></pre>
<pre><code>## Lade nötiges Paket: mgcv</code></pre>
<pre><code>## Lade nötiges Paket: nlme</code></pre>
<pre><code>## This is mgcv 1.8-17. For overview type 'help("mgcv-package")'.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#bayesx.term.options(bs = "rw1")</span>
formula.bx  =<span class="st"> </span><span class="kw">sqrt</span>(y) ~<span class="st"> </span>belt +<span class="st"> </span>
<span class="st">  </span><span class="kw">sx</span>(trend, <span class="dt">bs=</span><span class="st">"rw1"</span>, <span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="fl">0.0005</span>) +<span class="st"> </span>
<span class="st">  </span><span class="kw">sx</span>(seasonal, <span class="dt">bs=</span><span class="st">"season"</span>, <span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="fl">0.1</span>)

<span class="kw">system.time</span>(
  mcmc.bx &lt;-<span class="st"> </span><span class="kw">bayesx</span>(<span class="dt">formula =</span> formula.bx, <span class="dt">data=</span>Drivers, 
      <span class="dt">control=</span><span class="kw">bayesx.control</span>(<span class="dt">family=</span><span class="st">"gaussian"</span>,
      <span class="dt">method=</span><span class="st">"MCMC"</span>, <span class="dt">hyp.prior =</span> <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">4</span>), 
      <span class="dt">iterations=</span>10000L, <span class="dt">burnin=</span>5000L))
)</code></pre></div>
<pre><code>##        User      System verstrichen 
##       1.315       0.440       1.837</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(mcmc.bx$effects$<span class="st">`</span><span class="dt">sx(trend)</span><span class="st">`</span>)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-20-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(mcmc.bx$effects$<span class="st">`</span><span class="dt">sx(seasonal)</span><span class="st">`</span>)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-20-2.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(mcmc.bx)</code></pre></div>
<pre><code>## Call:
## bayesx(formula = formula.bx, data = Drivers, control = bayesx.control(family = "gaussian", 
##     method = "MCMC", hyp.prior = c(4, 4), iterations = 10000L, 
##     burnin = 5000L))
##  
## Fixed effects estimation results:
## 
## Parametric coefficients:
##                Mean      Sd    2.5%     50%   97.5%
## (Intercept) 41.2732  0.1680 40.9561 41.2682 41.6095
## belt        -4.5724  1.0132 -6.4869 -4.5991 -2.4949
## 
## Smooth terms variances:
##                Mean     Sd   2.5%    50%  97.5%    Min    Max
## sx(seasonal) 0.2274 0.0724 0.1222 0.2132 0.3978 0.0755 0.5809
## sx(trend)    0.1945 0.0903 0.0722 0.1802 0.4198 0.0464 0.6270
##  
## Scale estimate:
##          Mean     Sd   2.5%    50%  97.5%
## Sigma2 2.7904 0.3150 2.2562 2.7965 3.4382
##  
## N = 192  burnin = 5000  DIC = 210.1897  pd = 45.40892  
## method = MCMC  family = gaussian  iterations = 10000  step = 10</code></pre>
</div>
</div>
<div id="empirischer-bayes" class="section level1">
<h1 class="hasAnchor">
<a href="#empirischer-bayes" class="anchor"></a>Empirischer Bayes</h1>
<div id="andere-ansatze" class="section level2">
<h2 class="hasAnchor">
<a href="#andere-ansatze" class="anchor"></a>Andere Ansätze</h2>
<ul>
<li>Schön hier: Gibbs-Sampler, da wir semi-konjugierte Prioris verwenden</li>
<li>Aber noch einfacher: wenn wir <span class="math inline">\(\tau\)</span> kennen würden, wäre <span class="math inline">\(\theta|\cdot\sim N(.)\)</span> und wir könnten Schlüsse analytisch ziehen<br>
</li>
<li>Analogie zum penalisierten Likelihod-Ansatz:</li>
</ul>
<p><span class="math display">\[ \begin{aligned}
\log(p(\theta|x))&amp;=\log(f(x|\theta))+\log(p(\theta))+C\\
&amp;=l(\theta)+\frac{\tau}{2}\theta^TQ\theta+C=l_{pen}(\theta)+C
\end{aligned}\]</span></p>
</div>
<div id="empirischer-bayes-ansatz" class="section level2">
<h2 class="hasAnchor">
<a href="#empirischer-bayes-ansatz" class="anchor"></a>Empirischer Bayes-Ansatz</h2>
<ul>
<li>Beim empirischen Bayes-Ansatz wird keine Priori-Information für die Hyperparameter spezifiziert</li>
<li>Die Hyperparameter werden aus den Daten geschätzt</li>
<li>Kein Bayesianisches Verfahren im eigentlichen Sinn</li>
<li>Verschiedene Methoden möglich</li>
</ul>
</div>
<div id="expectation-maximization-algorithmus" class="section level2">
<h2 class="hasAnchor">
<a href="#expectation-maximization-algorithmus" class="anchor"></a>Expectation-Maximization-Algorithmus</h2>
<p>Im obigen Beispiel wäre folgender Algorithmus sinnvoll, um den Maximum-A-Posteriori-Schätzer zu berechnen:</p>
<ol style="list-style-type: decimal">
<li>Schätze <span class="math inline">\(\theta\)</span> aus <span class="math inline">\(y\)</span> bei gegebenen <span class="math inline">\(\tau\)</span>
</li>
<li>Schätze <span class="math inline">\(\tau\)</span> als inverse Varianz aus <span class="math inline">\(\theta\)</span>
</li>
</ol>
<ul>
<li><p>Iteriere bis zur Konvergenz</p></li>
<li><p>Empirischer Bayes-Ansatz würde nach weniger Iterationen abbrechen (z.B. <span class="math inline">\(1. \to 2. \to 1.\)</span>)</p></li>
</ul>
</div>
<div id="restringierter-ml-schatzer-reml" class="section level2">
<h2 class="hasAnchor">
<a href="#restringierter-ml-schatzer-reml" class="anchor"></a>Restringierter ML-Schätzer (REML)</h2>
<ul>
<li>Grundidee des REML: Transformiere Daten, so dass nuisance Parameter in der Likelihood nicht mehr auftauchen</li>
<li>Hier: <span class="math inline">\(y\sim N(X\theta,\sigma^2 I)\)</span>
</li>
<li>Transformation z.B. <span class="math inline">\(A=I-X(X^TX)^{-1}X^T\)</span>:</li>
</ul>
<p><span class="math display">\[ \begin{aligned}
E(Ay)&amp;=E((I-X(X^TX)^{-1}X^T)y)\\
&amp;=X\theta-X(X^TX)^{-1}X^TX\theta=0\\
Var(Ay)&amp;=(I-X(X^TX)^{-1}X^T)^T (\sigma^2I) (I-X(X^TX)^{-1}X^T)\\
&amp;=\sigma^2(I-2(X(X^TX)^{-1}X^T)\\
&amp;+X(X^TX)^{-1}X^TX(X^TX)^{-1}X^T)\\
&amp;=\sigma^2(I-X(X^TX)^{-1}X^T)\\
\end{aligned}\]</span></p>
<ul>
<li>Schätze <span class="math inline">\(\tau\)</span> aus <span class="math inline">\(p(\tau|Ay)\)</span>, hängt nicht mehr von <span class="math inline">\(\theta\)</span> ab</li>
<li>Setze Schätzung in ursprüngliche Posteriori ein: <span class="math inline">\(p(\theta|y,\hat{\tau})\)</span>
</li>
</ul>
</div>
<div id="bayesx-mit-reml" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#bayesx-mit-reml" class="anchor"></a>BayesX mit REML</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Keine Hyperparameter (!)</span>
formula.bx2 =<span class="st"> </span><span class="kw">sqrt</span>(y) ~<span class="st"> </span>belt +<span class="st"> </span><span class="kw">sx</span>(trend, <span class="dt">bs=</span><span class="st">"rw1"</span>) +<span class="st"> </span>
<span class="st">  </span><span class="kw">sx</span>(seasonal, <span class="dt">bs=</span><span class="st">"season"</span>)

reml.bx &lt;-<span class="st"> </span><span class="kw">bayesx</span>(<span class="dt">formula =</span> formula.bx2, <span class="dt">data=</span>Drivers, 
              <span class="dt">control=</span><span class="kw">bayesx.control</span>(<span class="dt">family=</span><span class="st">"gaussian"</span>,
              <span class="dt">method=</span><span class="st">"REML"</span>))

<span class="kw">plot</span>(reml.bx$effects$<span class="st">`</span><span class="dt">sx(trend)</span><span class="st">`</span>)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-21-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(reml.bx$effects$<span class="st">`</span><span class="dt">sx(seasonal)</span><span class="st">`</span>)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-21-2.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(reml.bx)</code></pre></div>
<pre><code>## Call:
## bayesx(formula = formula.bx2, data = Drivers, control = bayesx.control(family = "gaussian", 
##     method = "REML"))
##  
## Fixed effects estimation results:
## 
## Parametric coefficients:
##             Estimate Std. Error  t value  Pr(&gt;|t|)    
## (Intercept)  41.2769     0.1665 247.8527 &lt; 2.2e-16 ***
## belt         -4.6514     1.0544  -4.4114 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Smooth terms:
##              Variance Smooth Par.       df Stopped
## sx(seasonal)   0.0193    117.0120  14.2552       0
## sx(trend)      0.2541      8.8647  19.0758       0
##  
## Scale estimate: 2.2527 
##  
## N = 192  df = 35.331  AIC = 383.257  BIC = 498.347  
## GCV = 2.76067  logLik = -156.2975  method = REML  family = gaussian</code></pre>
</div>
<div id="model-averaging" class="section level2">
<h2 class="hasAnchor">
<a href="#model-averaging" class="anchor"></a>Model Averaging</h2>
<ul>
<li><p>Uns interessiert eigentlich die marginale Posterioriverteilung von <span class="math inline">\(\theta\)</span>. Für diese gilt: <span class="math display">\[
p(\theta|y)=\int p(\theta,\tau|y) d\tau = \int p(\theta|\tau,y)p(\tau|y) d\tau
\]</span></p></li>
<li>Im Gegensatz zum Empirischen Bayes-Ansatz erhalten wir beim vollen Bayes-Ansatz also nicht das Ergebnis für einen <span class="math inline">\(\tau\)</span>-Wert, sondern die Mischung von verschiedenen Modellen, gewichtet mit der marginalen Posteriori-Verteilung von <span class="math inline">\(\tau\)</span>.</li>
<li><p>Man spricht vom <em>Model Averaging</em></p></li>
</ul>
</div>
</div>
<div id="integreated-nested-laplace-approximation" class="section level1">
<h1 class="hasAnchor">
<a href="#integreated-nested-laplace-approximation" class="anchor"></a>Integreated Nested Laplace Approximation</h1>
<div id="integrated-nested-laplace-approximation-inla" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#integrated-nested-laplace-approximation-inla" class="anchor"></a>Integrated Nested Laplace Approximation (INLA)</h2>
<p><span class="math display">\[
p(\tau|y) = \frac{p(\theta,\tau|y)}{p(\theta|\tau,y)}
\]</span></p>
<ul>
<li>Zähler ist bekannt bis auf Normierungskonstante, Zähler ist Dichte der Normalverteilung.</li>
<li>Für jeden gegebenen Wert von <span class="math inline">\(\tau\)</span> kann Posteriori-Modus <span class="math inline">\(\theta^*(\tau)\)</span> leicht berechnet werden</li>
<li>Benutze Laplace-Approximation:</li>
</ul>
<p><span class="math display">\[
\tilde{p}(\tau|y) = \left.\frac{p(\theta,\tau|y)}{p(\theta|\tau,y)}\right|_{\theta=\theta^*(\tau)}
\]</span></p>
</div>
<div id="inla-algorithmus" class="section level2">
<h2 class="hasAnchor">
<a href="#inla-algorithmus" class="anchor"></a>INLA-Algorithmus:</h2>
<ul>
<li>Schätze Modus von <span class="math inline">\(\tau|y\)</span>
</li>
<li>Berechne <span class="math inline">\(\tilde{p}(\tau|y)\)</span> an geschickt gewählten Stützpunken um den Modus (berücksichtige Hessematrix)</li>
<li>Interpolation von <span class="math inline">\(\tilde{p}(\tau|y)\)</span> zwischen den Stützpunkten</li>
<li>Schliesslich numerische Integration:</li>
</ul>
<p><span class="math display">\[ 
\tilde{p}(\theta|y)=\sum_\tau p(\theta|\tau,y)\tilde{p}(\tau|y)
\]</span></p>
</div>
<div id="r-inla" class="section level2">
<h2 class="hasAnchor">
<a href="#r-inla" class="anchor"></a>R-INLA</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#install.packages("INLA", repos="https://inla.r-inla-download.org/R/stable")</span>
<span class="kw">library</span>(INLA)
formula  =<span class="st"> </span><span class="kw">sqrt</span>(y) ~<span class="st"> </span>belt +<span class="st"> </span><span class="kw">f</span>(trend, <span class="dt">model=</span><span class="st">"rw1"</span>, 
  <span class="dt">param=</span><span class="kw">c</span>(a.c,b.c)) +<span class="st"> </span><span class="kw">f</span>(seasonal, <span class="dt">model=</span><span class="st">"seasonal"</span>, 
  <span class="dt">season.length=</span><span class="dv">12</span>, <span class="dt">param=</span><span class="kw">c</span>(a.d,b.d))
inla.mod &lt;-<span class="st"> </span><span class="kw">inla</span>(formula, <span class="dt">family=</span><span class="st">"gaussian"</span>, 
  <span class="dt">data=</span>Drivers, <span class="dt">control.family=</span><span class="kw">list</span>(<span class="dt">param=</span><span class="kw">c</span>(a.s,b.s)))
<span class="kw">plot</span>(inla.mod)
<span class="kw">summary</span>(inla.mod)</code></pre></div>
<pre><code>## 
## Call:
## c("inla(formula = formula, family = \"gaussian\", data = Drivers, ",  "    control.family = list(param = c(a.s, b.s)))")
## 
## Time used:
##  Pre-processing    Running inla Post-processing           Total 
##          2.1144          1.1365          0.3562          3.6071 
## 
## Fixed effects:
##                mean     sd 0.025quant 0.5quant 0.975quant    mode kld
## (Intercept) 41.2413 0.1562    40.9334  41.2414    41.5479 41.2417   0
## belt        -4.3543 1.0683    -6.4578  -4.3561    -2.2432 -4.3585   0
## 
## Random effects:
## Name   Model
##  trend   RW1 model 
## seasonal   Seasonal model 
## 
## Model hyperparameters:
##                                            mean      sd 0.025quant
## Precision for the Gaussian observations  0.6563  0.1024     0.4785
## Precision for trend                      6.5927  3.2793     2.3134
## Precision for seasonal                  29.8273 14.3786    10.7541
##                                         0.5quant 0.975quant    mode
## Precision for the Gaussian observations   0.6484     0.8798  0.6329
## Precision for trend                       5.9133    14.8417  4.7457
## Precision for seasonal                   26.9415    65.7385 21.8956
## 
## Expected number of effective parameters(std dev): 56.53(9.872)
## Number of equivalent replicates : 3.396 
## 
## Marginal log-Likelihood:  -365.07</code></pre>
<p>Besser wäre vielleicht RW2:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">formula2  =<span class="st"> </span><span class="kw">sqrt</span>(y) ~<span class="st"> </span>belt +<span class="st"> </span><span class="kw">f</span>(trend, <span class="dt">model=</span><span class="st">"rw2"</span>,
  <span class="dt">param=</span><span class="kw">c</span>(a.c,b.c)) +<span class="st"> </span><span class="kw">f</span>(seasonal, <span class="dt">model=</span><span class="st">"seasonal"</span>, 
  <span class="dt">season.length=</span><span class="dv">12</span>, <span class="dt">param=</span><span class="kw">c</span>(a.d,b.d))
mod2 =<span class="st"> </span><span class="kw">inla</span>(formula, <span class="dt">family=</span><span class="st">"gaussian"</span>, <span class="dt">data=</span>Drivers,
           <span class="dt">control.family=</span><span class="kw">list</span>(<span class="dt">param=</span><span class="kw">c</span>(a.s,b.s)))
<span class="kw">plot</span>(mod2)</code></pre></div>
</div>
</div>
<div id="hierarchische-bayes-modelle" class="section level1">
<h1 class="hasAnchor">
<a href="#hierarchische-bayes-modelle" class="anchor"></a>Hierarchische Bayes-Modelle</h1>
<div id="allgemeiner-oder-generalisiert" class="section level2">
<h2 class="hasAnchor">
<a href="#allgemeiner-oder-generalisiert" class="anchor"></a>Allgemeiner (oder “Generalisiert”“)</h2>
<p>Allgemein gilt für hierarchische Modelle:</p>
<p><span class="math display">\[ \begin{aligned}
p(\theta|y)
&amp;= \int p(\theta|\tau, y) p(\tau| y) \; d\tau\\
&amp;= \int \frac{p(y|\theta) p(\theta|\tau)}{p(y|\tau)} p(\tau|y) \; d \tau
\end{aligned}\]</span></p>
<p><span class="math display">\[
  p(\tau|y) = \int p(\tau|\theta) p(\theta|y) \; d\theta
\]</span></p>
</div>
<div id="beispiel-modell-mit-zufalligen-effekten" class="section level2">
<h2 class="hasAnchor">
<a href="#beispiel-modell-mit-zufalligen-effekten" class="anchor"></a>Beispiel: Modell mit zufälligen Effekten</h2>
<p>Daten:</p>
<ul>
<li>Todesfälle nach Herzoperationen bei Babies</li>
<li>Beobachtungen von 12 Krankenhäusern</li>
<li>Annahme: Todesrate ist Krankenhausspezifisch</li>
<li>Individuelle Raten der Krankenhäuser kommen aus gemeinamer Verteilung</li>
</ul>
</div>
<div id="daten" class="section level2">
<h2 class="hasAnchor">
<a href="#daten" class="anchor"></a>Daten</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(INLA); <span class="kw">data</span>(Surg)
<span class="kw">plot</span>(Surg$r/Surg$n, <span class="dt">pch=</span><span class="st">'X'</span>, <span class="dt">ylab=</span><span class="st">'Rate'</span>, <span class="dt">xlab=</span><span class="st">'Krankenhaus'</span>)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/surg%20daten-1.png" width="672"></p>
</div>
<div id="hierarchisches-modell" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#hierarchisches-modell" class="anchor"></a>Hierarchisches Modell</h2>
<ul>
<li>Datenmodell: Sei <span class="math inline">\(y_i\)</span> die Anzahl der Todesfälle bei <span class="math inline">\(n_i\)</span> Operationen in Krankenhau <span class="math inline">\(i=1,\ldots,p=12\)</span>;</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
y_i &amp;\sim B(n_i, \pi_i); i=1,\ldots,p\\
\pi_i &amp;= \frac{exp(\theta_i)}{1-\exp(\theta_i)}
\end{aligned}
\]</span></p>
<ul>
<li>Priori-Modell</li>
</ul>
<p><span class="math display">\[ \begin{aligned}
\theta_i|\tau &amp; \sim N\left(\mu,\tau^{-1}\right)
\theta &amp; \sim N_p\left(\mu,(\tau I)^{-1})\right)
\end{aligned}
\]</span></p>
<ul>
<li>Hyper-Priori: Wie oben <span class="math inline">\(\tau Ga(a,b)\)</span>, <span class="math inline">\(a=b=1/1000\)</span>.</li>
</ul>
</div>
<div id="posteriori-und-full-conditionals" class="section level2">
<h2 class="hasAnchor">
<a href="#posteriori-und-full-conditionals" class="anchor"></a>Posteriori und Full Conditionals</h2>
<ul>
<li>Unterschied zu oben: Likelihood ist nicht mehr normal</li>
<li>Full Conditional von <span class="math inline">\(\theta\)</span> ist <em>fast</em> normal</li>
<li><p>Full Conditional von <span class="math inline">\(\tau\)</span> ist aber unverändert</p></li>
<li><p>Likelihood pro Krankenhaus:</p></li>
</ul>
<p><span class="math display">\[ \begin{aligned}
f(y_i|\theta_i) &amp;\propto \pi^{y_i}(1-\pi)^{n_i-y_i}\\
&amp; \propto \exp(\theta_i)^{y_i}(1-\exp(\theta))^{-y_i}(1-\exp(\theta))^{-n_i+y_i}\\
&amp; \propto \exp(y_i\theta_i)(1-\exp(\theta))^{n_i}
\end{aligned} 
\]</span></p>
</div>
<div id="approximation-der-full-conditionals" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#approximation-der-full-conditionals" class="anchor"></a>Approximation der Full Conditionals</h2>
<p>Full Conditional:</p>
<p><span class="math display">\[ \begin{aligned}
p(\theta|\tau,y)&amp;\propto \prod_i \exp(y_i\theta_i)(1-\exp(\theta))^{n_i} \exp(-\frac{\tau}{2}((\theta-\mu)^T(\theta-\mu)))\\
&amp;\propto \exp\sum_i\left(y_i\theta_i-\frac{\tau}{2}\theta_i^2+\tau(\theta_i-\mu)+n_i\log(1-\exp(\theta_i))\right)
\end{aligned}\]</span></p>
<p>Sei</p>
<p><span class="math display">\[ \begin{aligned}
f(\theta)&amp;:=\log(1-\exp(\theta))\\
f(\theta)'&amp;=\frac{-\exp(\theta)}{(1-\exp(\theta))}\\
f(\theta)''&amp;=\frac{-\exp(\theta)(1-\exp(\theta))-(-\exp(\theta))(-\exp(\theta))}{(1-exp(\theta))^2}\\
&amp;=\frac{-\exp(\theta)}{(1-\exp(\theta))^2}
\end{aligned}\]</span></p>
<p>Taylor-Approximation:</p>
<p><span class="math display">\[ \begin{aligned}
f(\theta_i)&amp;\approx f(\theta^0_i)-(\theta_i-\theta^0_i)f'(\theta_i^0)+\frac{1}{2}(\theta_i-\theta^0_i)^2 f''(\theta^0_i)\\
&amp;= \theta_i\left(f'(\theta^0_i)-\theta^0_if''(\theta^0_i)\right)
                 +\frac{1}{2}\theta_i^2f''(\theta^0_i)+const.
\end{aligned} \]</span></p>
<p>Damit Approximation der Posteriori:</p>
<p><span class="math display">\[ \begin{aligned}
                 \tilde{p}(\theta|\tau,y) &amp;\propto \exp\left(y_i\theta_i-\frac{\tau}{2}(\theta^T\theta)+\tau\mu\theta\right.+\\
                 &amp;\left.+n_i\left(\theta_i\left(f'(\theta^0_i)-\theta^0_if''(\theta^0_i)\right)
+\frac{1}{2}\theta_i^2f''(\theta^0_i)\right)\right)\\
\tilde{p}(\theta_i|\tau,y) &amp;\propto\exp\left(\theta_i(\mu+y_i+n_if'(\theta^0_i)-n_i\theta^0_if''(\theta^0_i))\right.\\
                                                       &amp; -\left.\frac{1}{2}\theta^2_i(\tau+f''(\theta^0_i))
                                                       \right)
                                                       \end{aligned}
\]</span></p>
</div>
<div id="anwendung-der-approximation" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#anwendung-der-approximation" class="anchor"></a>Anwendung der Approximation</h2>
<ul>
<li>Bei <strong>Markov Chain Monte Carlo</strong>
</li>
</ul>
<ol style="list-style-type: decimal">
<li>benutze <span class="math inline">\(\tilde{p}(\theta^{(k-1)})\)</span> als Proposal, wobei <span class="math inline">\(\theta^{(k-1)}\)</span> der aktuelle Wert ist</li>
<li>benutze <span class="math inline">\(\tilde{p}(\theta^*\)</span> als Proposal, wobei <span class="math inline">\(\theta^*\)</span> (approximativ) der Modus von <span class="math inline">\(p(\theta|\tau^{(k-1)})\)</span> ist (IWLS-Proposal)</li>
</ol>
<blockquote>
<p>BayesX hat bei Kombination MCMC, Binomial und Zufälliger Effekt (random effect, re) einen bekannten Bug.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(R2BayesX)
SurgBx &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y=</span><span class="kw">as.factor</span>(<span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>,<span class="kw">sum</span>(Surg$r)),
   <span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">sum</span>(Surg$n-Surg$r)))), <span class="dt">hospital=</span><span class="kw">c</span>(
    <span class="kw">rep</span>(Surg$hospital,Surg$r),<span class="kw">rep</span>(Surg$hospital,
                                    (Surg$n-Surg$r))))
b &lt;-<span class="st"> </span><span class="kw">bayesx</span>(y ~<span class="st"> </span><span class="kw">sx</span>(hospital, <span class="dt">bs =</span> <span class="st">"re"</span>),
    <span class="dt">data =</span> SurgBx, <span class="dt">family =</span> <span class="st">"binomial"</span>, <span class="dt">method =</span> <span class="st">"REML"</span>)
<span class="kw">summary</span>(b)</code></pre></div>
<pre><code>## Call:
## bayesx(formula = y ~ sx(hospital, bs = "re"), data = SurgBx, 
##     family = "binomial", method = "REML")
##  
## Fixed effects estimation results:
## 
## Parametric coefficients:
##             Estimate Std. Error t value  Pr(&gt;|t|)    
## (Intercept)  -2.5285     0.1378 -18.344 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##  
## Random effects variances:
##                 Variance Smooth Par.     df Stopped
## sx(hospital):re   0.1444      6.9238 6.9300       0
##  
## N = 2814  df = 7.93004  AIC = 1468.71  BIC = 1515.83  
## logLik = -726.425  GCV = 0.519216  method = REML  family = binomial</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(b$effects$<span class="st">`</span><span class="dt">sx(hospital):re</span><span class="st">`</span>$Estimate,<span class="dt">ylab=</span><span class="st">"theta"</span>)</code></pre></div>
<p><img src="HierarchischeModelle_files/figure-html/unnamed-chunk-24-1.png" width="672"></p>
<ul>
<li>Bei <strong>Integrated Nested Laplace Approximation</strong>
</li>
</ul>
<p><span class="math display">\[
                                                       \tilde{p}(\tau|y) = \left.\frac{p(\theta,\tau|y)}{\tilde{p}(\theta|\tau,y)}\right|_{\theta=\theta^*(\tau)}
\]</span></p>
<p><span class="math display">\[ 
                                                       \tilde{p}(\theta|y)=\sum_\tau \tilde{p}(\theta|\tau,y)\tilde{p}(\tau|y)
\]</span></p>
<p>INLA-Paket kennt drei verschiedene Approximationen (Gauss, Laplace, vereinfachter Laplace), die z.T. auch Schiefe berücksichtigen können.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">formula =<span class="st"> </span>r ~<span class="st"> </span><span class="kw">f</span>(hospital, <span class="dt">model=</span><span class="st">"iid"</span>,
                <span class="dt">param=</span><span class="kw">c</span>(<span class="fl">0.001</span>,<span class="fl">0.001</span>))
mod.surg =<span class="st"> </span><span class="kw">inla</span>(formula, <span class="dt">data=</span>Surg, 
                <span class="dt">family=</span><span class="st">"binomial"</span>, <span class="dt">Ntrials=</span>n)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(mod.surg)
<span class="kw">plot</span>(mod.surg$summary.random$hospital$mean)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rstan)</code></pre></div>
<pre><code>## Lade nötiges Paket: ggplot2</code></pre>
<pre><code>## Lade nötiges Paket: StanHeaders</code></pre>
<pre><code>## rstan (Version 2.15.1, packaged: 2017-04-19 05:03:57 UTC, GitRev: 2e1f913d3ca3)</code></pre>
<pre><code>## For execution on a local, multicore CPU with excess RAM we recommend calling
## rstan_options(auto_write = TRUE)
## options(mc.cores = parallel::detectCores())</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rstan_options</span>(<span class="dt">auto_write =</span> <span class="ot">TRUE</span>)
<span class="kw">options</span>(<span class="dt">mc.cores =</span> parallel::<span class="kw">detectCores</span>())</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stanmodel =<span class="st"> "</span>
<span class="st">data {</span>
<span class="st">    int&lt;lower=0&gt; n;</span>
<span class="st">    int&lt;lower=0&gt; H;</span>
<span class="st">    int&lt;lower=0&gt; hospital[n];</span>
<span class="st">    int&lt;lower=0&gt; y[n];</span>
<span class="st">    real&lt;lower=0&gt; a;</span>
<span class="st">    real&lt;lower=0&gt; b;</span>
<span class="st">}</span>
<span class="st">parameters {</span>
<span class="st">    vector[H] theta;</span>
<span class="st">    real mu;</span>
<span class="st">    real&lt;lower=0&gt; tau;</span>
<span class="st">}</span>
<span class="st">model {</span>
<span class="st">    for (i in 1:n) </span>
<span class="st">      y[i] ~ bernoulli_logit(theta[hospital[i]]);</span>
<span class="st">    for (i in 1:H) </span>
<span class="st">      theta[i] ~ normal(mu, sqrt(1/tau));</span>
<span class="st">    tau ~ gamma(a,b);</span>
<span class="st">}"</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a=<span class="fl">0.001</span>
b=<span class="fl">0.001</span>
standata &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">hospital=</span>SurgBx$hospital,
    <span class="dt">y=</span>SurgBx$y, <span class="dt">n=</span><span class="kw">length</span>(SurgBx$y), <span class="dt">H=</span><span class="dv">12</span>, <span class="dt">a=</span>a, <span class="dt">b=</span>b)
stan1 &lt;-<span class="st"> </span><span class="kw">stan</span>(<span class="dt">model_code =</span> stanmodel, 
    <span class="dt">model_name =</span> <span class="st">"Binomial"</span>,<span class="dt">data =</span> standata, 
    <span class="dt">iter =</span> <span class="dv">2000</span>, <span class="dt">warmup =</span> <span class="dv">1000</span>)</code></pre></div>
<pre><code>## In file included from file6d561f4fb8f0.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:12:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core/gevv_vvv_vari.hpp:5:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core/var.hpp:7:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/math/tools/config.hpp:13:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/config.hpp:39:
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/config/compiler/clang.hpp:196:11: warning: 'BOOST_NO_CXX11_RVALUE_REFERENCES' macro redefined [-Wmacro-redefined]
## #  define BOOST_NO_CXX11_RVALUE_REFERENCES
##           ^
## &lt;command line&gt;:6:9: note: previous definition is here
## #define BOOST_NO_CXX11_RVALUE_REFERENCES 1
##         ^
## In file included from file6d561f4fb8f0.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:42:
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core/set_zero_all_adjoints.hpp:14:17: warning: unused function 'set_zero_all_adjoints' [-Wunused-function]
##     static void set_zero_all_adjoints() {
##                 ^
## In file included from file6d561f4fb8f0.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:43:
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/core/set_zero_all_adjoints_nested.hpp:17:17: warning: 'static' function 'set_zero_all_adjoints_nested' declared in header file should be declared 'static inline' [-Wunneeded-internal-declaration]
##     static void set_zero_all_adjoints_nested() {
##                 ^
## In file included from file6d561f4fb8f0.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:11:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/prim/mat.hpp:59:
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/prim/mat/fun/autocorrelation.hpp:17:14: warning: function 'fft_next_good_size' is not needed and will not be emitted [-Wunneeded-internal-declaration]
##       size_t fft_next_good_size(size_t N) {
##              ^
## In file included from file6d561f4fb8f0.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:11:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/prim/mat.hpp:298:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/prim/arr.hpp:39:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/StanHeaders/include/stan/math/prim/arr/functor/integrate_ode_rk45.hpp:13:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/numeric/odeint.hpp:61:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/numeric/odeint/util/multi_array_adaption.hpp:29:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/multi_array.hpp:21:
## In file included from /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/multi_array/base.hpp:28:
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:42:43: warning: unused typedef 'index_range' [-Wunused-local-typedef]
##       typedef typename Array::index_range index_range;
##                                           ^
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:43:37: warning: unused typedef 'index' [-Wunused-local-typedef]
##       typedef typename Array::index index;
##                                     ^
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:53:43: warning: unused typedef 'index_range' [-Wunused-local-typedef]
##       typedef typename Array::index_range index_range;
##                                           ^
## /Library/Frameworks/R.framework/Versions/3.4/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:54:37: warning: unused typedef 'index' [-Wunused-local-typedef]
##       typedef typename Array::index index;
##                                     ^
## 8 warnings generated.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(stan1)</code></pre></div>
<pre><code>## Stan model 'Binomial' does not contain samples.</code></pre>
</div>
</div>
<div id="vergleich-der-methoden" class="section level1">
<h1 class="hasAnchor">
<a href="#vergleich-der-methoden" class="anchor"></a>Vergleich der Methoden</h1>
<div id="besprochene-methoden" class="section level2 allowframebreaks">
<h2 class="hasAnchor">
<a href="#besprochene-methoden" class="anchor"></a>Besprochene Methoden</h2>
<ul>
<li>MCMC selbst implementieren</li>
<li>Offensichtlich aufwendig</li>
<li>Kleine Tricks (z.B. log-Akzeptanzwahrscheinlichkeit)</li>
<li>Besser in z.B. C, C++</li>
<li><p>Vorteil: Kann beliebig verändert werden</p></li>
<li>STAN / HMC</li>
<li>(Scheint ziemlich) universell einsetzbar</li>
<li>Genauer Samplingalgorithmus schwer nachzuvollziehen (Fehler?)</li>
<li>Eventuell kryptische Fehlermeldungen</li>
<li><p>Je nach Modell sehr langsam oder sehr schnell</p></li>
<li>BayesX / REML und MCMC</li>
<li>Nur für bestimmte Modelle (Stukturiert additive Regression, STAR)</li>
<li>MCMC und REML, letzteres sehr schnell</li>
<li><p>R-Anbindung (noch) nicht gut, Standalone Software benutzen</p></li>
<li>INLA</li>
<li>Nur für STAR-Modelle, darin aber sehr flexibel</li>
<li>Kein MCMC, aber i.d.R. sehr gute Approximation</li>
<li><p>Dokumentation in R z.T. noch nicht fertig</p></li>
</ul>
</div>
<div id="alterativen" class="section level2">
<h2 class="hasAnchor">
<a href="#alterativen" class="anchor"></a>Alterativen</h2>
<ul>
<li>OpenBUGS (WinBUGS)</li>
<li>Klassiker (WinBUGS)</li>
<li>Generelles MCMC Sampling ähnlich STAN</li>
<li>Verschiedene, nicht ganz ausgereifte R-Anbindungen, dazu coda</li>
<li>In der WinBUGS-Variante sehr gute Visualisierung</li>
<li><p>JAGS: Neu geschriebene Alternative</p></li>
<li>LaplacesDemon (R)</li>
<li>MCMCpack (R)</li>
<li>mcmc (R)</li>
<li>… (siehe Bayesian Task View in R)</li>
<li>PyMC (Python)</li>
<li>emcee (Python)</li>
<li><p>Mamba (julia)</p></li>
</ul>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#hierarchische-modelle">Hierarchische Modelle</a><ul class="nav nav-pills nav-stacked">
<li><a href="#hierarchische-modelle-1">Hierarchische Modelle</a></li>
      <li><a href="#beispiel-zeitreihe-mit-saison-effekt">Beispiel: Zeitreihe mit Saison-Effekt</a></li>
      <li><a href="#datenmodell">Datenmodell</a></li>
      <li><a href="#priori-modell---zeittrend">Priori-Modell - Zeittrend</a></li>
      <li><a href="#priorimodell---saisontrend">Priorimodell - Saisontrend</a></li>
      <li><a href="#priori-modell---intercept-und-kovariableneffekt">Priori-Modell - Intercept und Kovariableneffekt</a></li>
      <li><a href="#hyperpriors">Hyperpriors</a></li>
      <li><a href="#posteriori">Posteriori</a></li>
      <li><a href="#full-conditional---zeitlicher-trend">Full conditional - Zeitlicher Trend</a></li>
      <li><a href="#full-conditional---saison-effekt">Full conditional - Saison-Effekt</a></li>
      <li><a href="#full-conditional---kovariableneffekt">Full conditional - Kovariableneffekt</a></li>
      <li><a href="#full-conditional---prazisionsparameter">Full Conditional - Präzisionsparameter**</a></li>
      <li><a href="#implementation">Implementation</a></li>
      <li><a href="#mcmc">MCMC</a></li>
      <li><a href="#ergebnisse">Ergebnisse</a></li>
      <li><a href="#bayesx">BayesX</a></li>
      </ul>
</li>
      <li>
<a href="#empirischer-bayes">Empirischer Bayes</a><ul class="nav nav-pills nav-stacked">
<li><a href="#andere-ansatze">Andere Ansätze</a></li>
      <li><a href="#empirischer-bayes-ansatz">Empirischer Bayes-Ansatz</a></li>
      <li><a href="#expectation-maximization-algorithmus">Expectation-Maximization-Algorithmus</a></li>
      <li><a href="#restringierter-ml-schatzer-reml">Restringierter ML-Schätzer (REML)</a></li>
      <li><a href="#bayesx-mit-reml">BayesX mit REML</a></li>
      <li><a href="#model-averaging">Model Averaging</a></li>
      </ul>
</li>
      <li>
<a href="#integreated-nested-laplace-approximation">Integreated Nested Laplace Approximation</a><ul class="nav nav-pills nav-stacked">
<li><a href="#integrated-nested-laplace-approximation-inla">Integrated Nested Laplace Approximation (INLA)</a></li>
      <li><a href="#inla-algorithmus">INLA-Algorithmus:</a></li>
      <li><a href="#r-inla">R-INLA</a></li>
      </ul>
</li>
      <li>
<a href="#hierarchische-bayes-modelle">Hierarchische Bayes-Modelle</a><ul class="nav nav-pills nav-stacked">
<li><a href="#allgemeiner-oder-generalisiert">Allgemeiner (oder “Generalisiert”“)</a></li>
      <li><a href="#beispiel-modell-mit-zufalligen-effekten">Beispiel: Modell mit zufälligen Effekten</a></li>
      <li><a href="#daten">Daten</a></li>
      <li><a href="#hierarchisches-modell">Hierarchisches Modell</a></li>
      <li><a href="#posteriori-und-full-conditionals">Posteriori und Full Conditionals</a></li>
      <li><a href="#approximation-der-full-conditionals">Approximation der Full Conditionals</a></li>
      <li><a href="#anwendung-der-approximation">Anwendung der Approximation</a></li>
      </ul>
</li>
      <li>
<a href="#vergleich-der-methoden">Vergleich der Methoden</a><ul class="nav nav-pills nav-stacked">
<li><a href="#besprochene-methoden">Besprochene Methoden</a></li>
      <li><a href="#alterativen">Alterativen</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Volker Schmid.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
